# Probability {#probability}

<!-- Put the empirical distribution first for our 4 probability distributions. Then, mathematical. Give the simple notation a single observation. Start the mathematical with the distribution of a single observation is described by this formula. y_i ~ Bernoulli(p). Expected value of y_i is this mathematical probability distribution. If your assumptions are correct, then as your sample size increases, the empirical probability distribution will look more and more like the mathematical distribution.  -->


<!-- Note Bernoulli is for a single coin toss, Bernoulli(p). Binomial is for an arbitrary number of coin tosses, Binomial(p, n). Read about expected values.  -->

<!-- Put in the same shorthand versions of probability notation as in chapter 2, to the extent we have them. -->

<!-- Start thinking about discussing "population". Maybe add a paragraph to each of the first three examples? (mostly in the first two because the third one posterior come from internet) Done.-->

<!-- Maybe show (but don't explain!) the actual math formula. -->

<!-- Add, on the mathematical distribution sections, the actual math formual. Learn about putting math. $$x + 1$$ Done.-->

<!-- When building the chapter, we don't want rayshader images to pop up! -->

<!-- Learn about movies in rayshader.  -->

<!-- What would be a fun theme/gif/movie clip to start and end the chapter with, like we do in chapters 4 and 6? Something having to do with betting . . . Connected to Kant? -->

<!-- Old stuff -->

<!-- Also good to get into the *scaling* of distributions, and the arbitrariness thereof. For example, trains$age is a distribution. Fine. What about rep(trains$age, 2)? What about rep(trains$age, 100)? Well, if any vector is a distribution, then all three of these are distributions. In fact, they are the same distribution, just scaled differently.  -->

<!-- When discussing a parameter $p$ and a probability distribution p() in the absence of a specific context, then those simple terms are OK. But, whenever you are talking about specific parameters or specific probability distributions, you should have either subscripts or items in the parentheses, respectively.  -->



<!-- Revisit these references and see if there is other stuff we should include:   -->

<!-- Teaching Bayes' Rule: A Data-Oriented Approach by Jim Albert. -->
<!-- Rethinking Chapter 2. Garden of forking data is just excellent stuff. -->
<!-- Bayesian Workshop -->

<!-- Wait on this. Maybe add, after N models, a section on Infinity models, meaning a continuous parameter p. Note that we have a continuous distribution section now. Want to set the stage for Chapter 6, in which we are generating a posterior for p which we may think of as taking an infinite number of values. This is a key dimension on which chapter 5 and 6 need to connect. Maybe not necessary? -->

*This chapter is being edited.*

> The usual touchstone of whether what someone asserts is mere persuasion or at least a subjective conviction, i.e., firm belief, is betting. Often someone pronounces his propositions with such confident and inflexible defiance that he seems to have entirely laid aside all concern for error. A bet disconcerts him. Sometimes he reveals that he is persuaded enough for one ducat but not for ten. For he would happily bet one, but at ten he suddenly becomes aware of what he had not previously noticed, namely that it is quite possible that he has erred. -— Immanuel Kant, *Critique of Pure Reason*

The central tension, and opportunity, in data science is the interplay between the *data* and the *science*, between our empirical observations and the models which we use to understand them. Probability is the language we use to explore that interplay; it connects models to data, and data to models.

The only package we need in this chapter is **tidyverse**.

```{r, message = FALSE}
library(tidyverse)
```

```{r, echo = FALSE, message = FALSE}
 # We also load the **rayshader** and **rgl** packages. We use them to create
 # the 3-D plots below. You can read more about **rayshader**
 # [here](https://www.rayshader.com/) but we will not be explaining how to use
 # it in this *Primer*.

library(rayshader)
library(rgl)
library(tidyverse)
library(magick)
library(primer.data)
```

## List-columns and map functions

Before learning about probability, we need to expand our collection of R tricks by understanding list-columns and `map_*` functions. Recall that a list is different from an atomic vector. In atomic vectors, each element of the vector has one value.  Lists, however, can contain vectors, and even more complex objects, as elements.

```{r}
x <- list(c(4, 16, 9), c("A", "Z"))
x
```

`x` is a list with two elements. The first element is a numeric vector of length 3. The second element is a character vector of length 2. We use `[[]]` to extract specific elements.

```{r}
x[[1]]
```

There are a number of built-in R functions that output lists. For example, the ***ggplot*** objects you have been making store all of the plot information in lists. Any function that returns multiple values can be used to create a list output by wrapping that returned object with `list()`.


```{r}
x <- rnorm(10)

# range() returns the min and max of the argument 

tibble(col_1 = list(range(x))) 
```

Notice this is a 1-by-1 tibble with one observation, which is a list of one element. Voila! You have just created a **list-column**.

*If a function returns multiple values as a vector, like `range()` does, you must use `list()` as a wrapper if you want to create a list-column.*

A list column is a column of your data which is a [list](https://adv-r.hadley.nz/vectors-chap.html#lists) rather than an atomic vector.  As with stand-alone list objects, you can pipe to `str()` to examine the column.

```{r}
tibble(col_1 = list(range(x))) %>%
  str()
```


We can use `map_*` functions to both create a list-column and then, much more importantly, work with that list-column afterwards. 

```{r}
tibble(col_1 = list(range(x))) %>%
  mutate(col_2 = map_dbl(col_1, ~ sum(.))) %>% 
  str()
```

`map_*` functions, like `map_dbl()` in this example, take two key arguments, `.x` (the data which will be acted on) and `.f` (the function which will act on this data). Here, `.x` is the data in `col_1`, which is a list-column. `.f` is the function `sum()`. However, we can not simply write `map_dbl(col_1, sum)`. Instead, each use of `map_*` functions requires the use of a tilde --- a `~` --- to indicate the start of the function and the use of a dot --- a `.` --- to specify where the data goes in the function.

`map_*` functions are a family of functions, with the suffix specifying the type of the object to be returned. `map()` itself returns a list. `map_dbl()` returns a double. `map_int()` returns an integer. `map_chr()` returns a character, and so on.

To summarise `map` function and `map_`* functions could both convert an data (vector or list) with the specific denoted functions or formula you set, and always results in list we called the  "list Column". There are two arguments in the `map()` function as well as `map_*()` function the `.x` and `.f`, the `.x` and `.f` placed in the `map()` functions and `map_*()`functions like this `map(.x,.f)`, where `.x` could either be a list or a vector, and `.f` either be a direct function like `.f=mean`, or an formula like `.f= ~mean(.x)`, remember to put the `~` if you are using `.f` an formula, the difference between `map` and `map_*` function is when you know and want the outcome of the data to be specific data vector like (`double`, `logical`,`character`,`integer`) rather than an general `list` in `map()`, you can use `map_*` instead of `map` to organized your list column.


```{r}
tibble(ID = 1) %>% 
  mutate(col_1 = map(ID, ~range(rnorm(10)))) %>%
  mutate(col_2 = map_dbl(col_1, ~ sum(.))) %>% 
  mutate(col_3 = map_int(col_1, ~ length(.))) %>% 
  mutate(col_4 = map_chr(col_1, ~ sum(.))) %>% 
  str()
```

Consider a more detailed example:


```{r}
# This simple example demonstrates the workflow which we will often follow.
# Start by creating a tibble which will be used to store the results. (Or start
# with a tibble which already exists and to which you will be adding more
# columns.) It is often convenient to get all the code working with just a few
# rows. Once it is working, we increase the number of rows to a thousand or
# million or whatever we need.

tibble(ID = 1:3) %>% 
  
  # The big convenience is being able to store a list in each row of the tibble.
  # Note that we are not using the value of ID in the call to rnorm(). (That is
  # why we don't have a "." anywhere.) But we are still using ID as a way of
  # iterating through each row; ID is keeping count for us, in a sense.
  
  mutate(draws = map(ID, ~ rnorm(10))) %>% 
  
  # Each succeeding step of the pipe works with columns already in the tibble
  # while, in general, adding more columns. The next step calculates the max
  # value in each of the draw vectors. We use map_dbl() because we know that
  # max() will returns a single number.
  
  mutate(max = map_dbl(draws, ~ max(.))) %>% 
  
  # We will often need to calculate more than one item from a given column like
  # draws. For example, in addition to knowing the max value, we would like to
  # know the range. Because the range is a vector, we need to store the result
  # in a list column. map() does that for us automatically.
  
  mutate(min_max = map(draws, ~ range(.)))

```

This flexibility is only possible via the use of list-columns and  `map_*` functions. This workflow is extremely common. We start with an empty tibble, using ID to specify the number of rows. With that skeleton, each step of the pipe adds a new column, working off a column which already exists. 


## Probability distributions

```{r, echo = FALSE, fig.cap = "Dice and Probability."}
knitr::include_graphics("05-probability/images/probability_dice.jpeg")
```


What does it mean that Trump had a *30% chance* of winning re-election in the fall of 2020? That there is a *90% probability* of rain today? That the dice at the casino are *unfair*? 

Probability is about quantifying uncertainty. We can think of probability as a proportion. The probability of an event occurring is a number from 0 to 1, where 0 means that the event is impossible and 1 means that the event is 100% certain.

Let's begin with the simplest events: coin flips and dice rolls. If the dice and the coins are fair, we can operate under the assumption that all outcomes are equally likely. 

This allows us to make the following statements:

* The probability of rolling a 1 or a 2 is 2/6, or 1/3.
* The probability of rolling a 1, 2, 3, 4, 5, or 6 is 1.  
* The probability of flipping a coin and getting tails is 1/2.

<!-- DK: What is the difference between a distribution and a probability distribution? After all, we can define them both with draws. And the draws can look like anything. And you can turn any distribution into a probability distribution via normalization. -->

For the purposes of this *Primer*, a *probability distribution* is a mathematical object that covers a set of outcomes, where each distinct outcome has a chance of occurring between 0 and 1 inclusive. The chances must sum to 1. The set of possible outcomes --- heads or tails for the coin, 1 through 6 for a single die, 2 through 12 for a pair of dice --- can be either discrete or continuous. Remember, discrete data is information where we can only take certain value. On the other hand, continuous data is data we can take any values, like height and weight they are in a sense "continuous". This set of outcomes is the *domain* of the probability distribution. There are three types of probability distributions: mathematical, empirical, and posterior. 

The key difference between a distribution, as we have explored them Section \@ref(distributions), and a *probability* distribution is the requirement that the sum of the probabilities of the individual outcomes must be exactly 1. There is no such requirement in a distribution. But any distribution can be turned into a probability distribution by "normalizing" it, as we will explore.  In this context, we will often refer to a distribution which is not (yet) a probability distribution as an "unnormalized" distribution.  

Pay attention to notation. Whenever we are talking about a specific probability (represented by a single value), we will use $\rho$ (the Greek letter "rho" but spoken aloud as "p" by us) with a *subscript* which specifies the exact outcome of which it is the probability. For instance, $\rho_h = 0.5$ denotes the probability of getting heads on a coin toss when the coin is fair. $\rho_t$ --- spoken as "PT" or "P sub T" or "P tails" --- denotes the probability of getting tails on a coin toss. However, when we are referring to the entire probability distribution over a set of outcomes, we will use $\text{Prob}()$. For example, the probability distribution of a coin toss is $\text{Prob}(\text{coin})$. That is, $\text{Prob}(\text{coin})$ is composed of the two specific probabilities (50% and 50%) mapped from the two values in the domain (Heads and Tails). Similarly, $\text{Prob}(\text{sum of two dice})$ is the probability distribution over the set of 11 outcomes (2 through 12) which are possible when you take the sum of two dice. $\text{Prob}(\text{sum of two dice})$ is made up of 11 numbers --- $\rho_2$,  $\rho_3$, ..., $\rho_{12}$ --- each representing the unknown probability that the sum will equal their value. That is, $\rho_2$ is the probability of rolling a 2.


<!-- DK: Above is not clear. Explain this better by showing that a distribution is just a vector. A probability distribution is a vector in which each element of the vector is mapped to a 0--1 probability, the sum of which is one. Need to connect this more clearly to joint distribution discussion. Update: This isn't quite right either. -->


### Flipping a coin

All data science problems start with a question. Example: *What will be the result of the next flip of a coin?* All questions are answered with the help of probability distributions.

A *mathematical distribution* is based on a mathematical formula. Assuming that the coin is perfectly fair, we should, on average, get heads as often as we get tails.


```{r, echo = FALSE}

# Flipping one coin 100 times

mydata <- tibble(results = c(rep(0, 50),
                             rep(1, 50)))

ggplot(mydata, aes(x = results)) +
  geom_histogram(aes(y = after_stat(count/sum(count))), 
                 binwidth = 0.5, 
                 color = "white") +
  labs(title = "Mathematical Probability Distribution",
       subtitle = "Expectations for flipping a fair coin",
       x = "Outcome\nResult of Coin Flip",
       y = "Probability") +
  scale_x_continuous(breaks = c(0, 1), 
                     labels = c("Heads", "Tails")) +
  scale_y_continuous(labels =
                      scales::percent_format(accuracy = 1)) +
  theme_classic()

```



An *empirical distribution* is based on data. You can think of this as the probability distribution created by running a simulation. In theory, if we increase the number of coins we flip in our simulation, the empirical distribution will look more and more similar to the mathematical distribution. The mathematical distribution is the Platonic form. The empirical distribution will often look like the mathematical probability distribution, but it will rarely be exactly the same.

In this simulation, there are 56 heads and 44 tails. The outcome will vary every time we run the simulation, but the proportion of heads to tails should not be too different if this coin is fair.

<!-- YW: "The proportion of heads to tails should not be too difference if this coin is fair" I get the point, I think it would be better if connects to the large chunk of explanation of $\rho$ and specific probability in this discussion. Agreed! -->



```{r}
# We are flipping one fair coin a hundreds times. We need to get the same result
# each time we create this graphic because we want the results to match the
# description in the text. Using set.seed() guarantees that the random results
# are the same each time. We define 0 as tails and 1 as heads.

set.seed(3)

tibble(results = sample(c(0, 1), 100, replace = TRUE)) %>% 
  ggplot(aes(x = results)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.5, 
                   color = "white") +
    labs(title = "Empirical Probability Distribution",
         subtitle = "Flipping one coin a hundred times",
         x = "Outcome\nResult of Coin Flip",
         y = "Probability") +
    scale_x_continuous(breaks = c(0, 1), 
                       labels = c("Heads", "Tails")) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()
```


A *posterior distribution* is based on beliefs and expectations. It displays your belief about things you can't see right now. You may have posterior distributions for outcomes in the past, present, or future.

In the case of the coin toss, the posterior distribution changes depending on your beliefs. For instance, let's say your friend brought a coin to school and asked to bet you. If the result is heads, you have to pay them $5. 

This makes you suspicious, or in other world you no longer trust the "population" that was made in the previous two examples, that is all the results and probability was based on flipping a fair coin, and that's why the only way left (if you don't jsut simply walk away) is your posterior distribution. Your posterior distribution reflects or beliefs based on the assumption, this time the population is no longer the fair dice where we define $\rho_h$=0.5, is the population of "crooked" dice where you might believe that $\rho_h$ is 0.95 and $\rho_t$ is 0.05.


```{r, echo = FALSE}

# Flipping one coin 100 times

mydata <- tibble(results = c(rep(0, 95),
    rep(1, 5)))

ggplot(mydata, aes(x = results)) +
  geom_histogram(aes(y = after_stat(count/sum(count))), 
                 binwidth = 0.5, 
                 color = "white") +
  labs(title = "Posterior Probability Distribution",
       subtitle = "Your beliefs about flipping one coin to bet your friend",
       x = "Outcome\nResult of Coin Flip",
       y = "Probability") +
  scale_x_continuous(breaks = c(0, 1), 
                     labels = c("Heads", "Tails")) +
  scale_y_continuous(labels = 
                       scales::percent_format(accuracy = 1)) +
  theme_classic()

```

The full terminology is mathematical (or empirical or posterior) *probability* distribution. But we will often shorten this to just mathematical (or empirical or posterior) distribution. The word "probability" is understood, even if it is not present.

<!-- DK: Add a paragraph discussing the concept of a population. And why or why not we could use our empirical data. Thinking about the population helps you decide whether (or not) to make use of the mathematical and empirical distributions when you are creating your posterior. -->

<!-- Determine a good definition of population. The population is the set of all units from which the data you have, and the data you want to have, has been, or will be, drawn. -->

<!-- DK: Tie this more closely to the notion of distribution in chapter 2. In particular, recall the distinction between a distribution and draws from a distribution. -->


### Rolling two dice

Our *mathematical distribution* tells us that, with a fair dice, the probability of getting 1, 2, 3, 4, 5, and 6 are equal: there is a 1/6 chance of each. When we roll two dice at the same time and sum the numbers, the values closest to the middle are more common than values at the edge because there are more combinations of numbers that add up to the middle values.


```{r, echo = FALSE}
tibble(sum = c(rep(c(2, 12), 1), 
               rep(c(3, 11), 2),
               rep(c(4, 10), 3), 
               rep(c(5,  9), 4),
               rep(c(6,  8), 5),
               rep(c(7), 6))) %>% 
  ggplot(aes(x = sum)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 1, 
                   color = "white") +
    labs(title = "Mathematical Probability Distribution",
         subtitle = "Expectation for the sum from rolling two dice",
         x = "Outcome\nSum of Two Die",
         y = "Probability") +
    scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()
```



We get an *empirical distribution* by rolling two dice a hundred times, either by hand or with a computer simulation. The result is not identical to the mathematical distribution because of the inherent randomness of the real world and/or of simulation. 

```{r}
# In the coin example, we create the vector ahead of time, and then assigned
# that vector to a tibble. There was nothing wrong with that approach. And we
# could do the same thing here. But the use of map_* functions is more powerful.

set.seed(1)

emp_dist_dice <- tibble(ID = 1:100) %>% 
  mutate(die_1 = map_dbl(ID, ~ sample(c(1:6), size = 1))) %>% 
  mutate(die_2 = map_dbl(ID, ~ sample(c(1:6), size = 1))) %>% 
  mutate(sum = die_1 + die_2) %>% 
  ggplot(aes(x = sum)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 1, 
                   color = "white") +
    labs(title = "Empirical Probability Distribution",
         subtitle = "Sum from rolling two dice, replicated one hundred times",
         x = "Outcome\nSum of Two Die",
         y = "Probability") +
    scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()

emp_dist_dice
```

We might consider labeling the y-axis in plots of empirical distributions as "Proportion" rather than "Probability" since it is an actual proportion, calculated from real (or simulated) data. We will keep it as "Probability" since we want to emphasize the parallels between mathematical, empirical and posterior probability distributions.


The *posterior distribution* for rolling two dice a hundred times depends on your beliefs. If you take the dice from your Monopoly set, you have reason to believe that the assumptions underlying the mathematical distribution are true. However, if you walk into a crooked casino and a host asks you to play craps, you might be suspicious, just as in the "flipping a coin example" the word "suspicious" means you no longer trust the "population" where the mathematical and empircal distribution drawn their data from. For example, in craps, a come-out roll of 7 and 11 is a "natural," resulting in a win for the "shooter" and a loss for the casino. You might expect those numbers to occur less often than they would with fair dice. Meanwhile, a come-out roll of 2, 3 or 12 is a loss for the shooter. You might also expect values like 2, 3 and 12 to occur more frequently. Your posterior distribution might look like this:

```{r, echo = FALSE}
# Hard code our posterior about the crooked casino.

tibble(results = c(rep(2, 15), rep(3, 15), rep(4, 7), 
                   rep(5, 7), rep(6, 7), rep(7, 4),
                   rep(8, 7), rep(9, 7), rep(10, 7), 
                   rep(11, 3), rep(12, 15))) %>% 
  ggplot(aes(x = results)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 1, 
                   color = "white") +
    labs(title = "Posterior Probability Distribution",
         subtitle = "Your belief about the sum of two dice at a crooked casino",
         x = "Outcome\nSum of Two Die",
         y = "Probability") +
    scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()

```

Someone less suspicious of the casino would have a posterior distribution which looks more like the mathematical distribution.

### Presidential elections

Now let's say we are building probability distributions for political events, like a presidential election. We want to know the probability that Democratic candidate wins X electoral votes, where X comes from the range of possible outcomes: 0 to 538. (The total number of electoral votes in US elections since 1964 is 538.)

We can start with a *mathematical distribution* for X which assumes that the chances of the Democratic candidate winning any given state's electoral votes is 0.5 and the results from each state are independent.

```{r, echo = FALSE}
# Add comments explaining what this does.

ev <- c(rep(3, 8), rep(4, 5), rep(5, 3), rep(6, 6), rep(7, 3), rep(8,2),
        rep(9, 3), rep(10, 4), rep(11, 4), 12, 13, 14, 15, rep(16, 2), 18, 20 , 20, 19, 29, 38, 55)

sims <- 10000

result <- tibble(total = (matrix(rbinom(sims*length(ev),
                        size = 1, p = 0.5),
                 ncol = length(ev)) %*% ev)[,1])

ggplot(data = result, aes(total)) +
  geom_histogram(aes(y= after_stat(count/sum(count))), 
                 binwidth = 1) +
  labs(title = "Mathematical Probability Distribution",
       subtitle = "Presidential elections with each state being 50/50 and independent",
       y = "Probability",
       x = "Outcome\nElectoral Vote Total for Democratic Candidate") +
  scale_y_continuous(labels = 
                       scales::percent_format()) +
  theme_classic()

```



We know that campaign platforms, donations, charisma, and many other factors will contribute to a candidate's success. Elections are more complicated than coin tosses. We also know that many presidential elections in history have resulted in much bigger victories or defeats than this distribution seems to allow for.

The *empirical distribution* in this case could involve looking into past elections in the United States and counting the number of electoral votes that the Democrats won in each. For the empirical distribution, we create a tibble with electoral vote results from past elections. Looking at elections since 1964, we can observe that the number of electoral votes that the Democrats received in each one is different. Given that we only have 15 entries, it is difficult to draw conclusions or make predictions based off of this empirical distribution.

However, this model is enough to suggest that the assumptions of the mathematical probability distribution above do not work for electoral votes. The model assumes that the Democrats have a 50% chance of receiving each of the 538 votes. Just looking at the mathematical probability distribution, we can observe that receiving 13 or 17 or 486 votes out of 538 would be extreme and almost impossible under this mathematical model. However, our empirical distribution tells us that those were real election results.

We are using the past elections data in the *mathematical* and *empirical* distribution is because we think that the performance of past elections could influence the election in 2020.


```{r, echo = FALSE}
# Votes are since 1964, for Democratic candidate

mydata <- tibble(electoral_votes = c(486,191,17,297,49,13,111,370,379,
                      266,251,365,332,227,306))

#306 is electoral votes for Joe Biden in 2020 presidential election.

ggplot(mydata, aes(x = electoral_votes)) +
  geom_histogram(aes(y = after_stat(count/sum(count))), 
                 bins = 100, 
                 color = "white") +
  labs(title = "Empirical Probability Distribution",
       subtitle = "Electoral votes from 16 previous elections",
       x = "Outcome\nElectoral Vote Total for Democratic Candidate",
       y = "Probability") +
  scale_y_continuous(labels = 
                       scales::percent_format(accuracy = 1)) +
  theme_classic()

```

The *posterior distribution* of electoral votes is a popular topic, and an area of strong disagreement, among data scientists. Consider this posterior from *FiveThirtyEight*.

```{r, echo = FALSE}
# DK: Some comments about this. Where did you get this data from? Why those
# columns? 

read_csv("./05-probability/data/election-forecasts-2020/prez_1.csv",
         col_types = cols(cycle = col_double(),
                          branch = col_character(),
                          model = col_character(),
                          modeldate = col_character(),
                          candidate_inc = col_character(),
                          candidate_chal = col_character(),
                          candidate_3rd = col_logical(),
                          evprob_inc = col_double(),
                          evprob_chal = col_double(),
                          evprob_3rd = col_logical(),
                          total_ev = col_double(),
                          timestamp = col_character(),
                          simulations = col_double())) %>%
  select(evprob_chal, total_ev)  %>% 
  rename(prob = evprob_chal, electoral_votes = total_ev) %>% 
  ggplot(aes(electoral_votes, prob)) +
    geom_bar(stat = 'identity') +
    labs(title = "Posterior Probability Distribution",
         subtitle = "Democratic electoral votes according to 538 forecast",
         y = "Probability",
         x = "Outcome\nElectoral Vote Total for Democratic Candidate",
         caption = "Data from August 13, 2020") +
  scale_y_continuous(breaks = c(0, 0.01, 0.02),
                     labels = 
                       scales::percent_format(accuracy = 1)) +
  theme_classic()

```


Here is a posterior from the FiveThirtyEight website from August 13, 2020. This was created using the same data as the above distribution, but simply displayed differently. For each electoral result, the height of the bar represents the probability that a given event will occur. However, there are no lablels y-axis telling us what the specific probability of each outcome is. And that is OK! The specific values are not that useful. If we removed the labels on our y-axes, would it matter?

```{r, echo = FALSE, caption = "FiveThirtyEight Posterior from August 13, 2020"}
knitr::include_graphics("05-probability/images/fivethirtyeight.png")
```

Here is the posterior from *The Economist*, also from August 13, 2020. This looks confusing at first because they chose to merge the axes for Republican and Democratic electoral votes. We can tell that *The Economist* was less optimistic, relative to *FiveThirtyEight*, about Trump's chances in the election.

```{r, echo = FALSE, caption = "Economist Posterior from August 13, 2020"}
knitr::include_graphics("05-probability/images/economist_aug13.png")
```

These two models, built by smart people using similar data sources, have reached fairly different conclusions. Data science is difficult! There is not one "right" answer. Real life is not a problem set. 

```{r, echo = FALSE,  out.width="100%", fig.cap = "Watch the makers of these two models throw shade at each other on Twitter! Eliot Morris is one of the primary authors of the Economist model. Nate Silver is in charge of 538. They don't seem to be too impressed with each other's work! More smack talk [here](https://statmodeling.stat.columbia.edu/2020/08/31/more-on-that-fivethirtyeight-prediction-that-biden-might-only-get-42-of-the-vote-in-florida/) and [here](https://statmodeling.stat.columbia.edu/2020/08/31/problem-of-the-between-state-correlations-in-the-fivethirtyeight-election-forecast/)."}
knitr::include_graphics("05-probability/images/538_versus_Economist.png")
```

There are many political science questions you could explore with posterior distributions. They can relate to the past, present, or future.

* Past: How many electoral votes would Hilary Clinton have won if she had picked a different VP?
* Present: What are the total campaign donations from Harvard faculty?
* Future: How many electoral votes will the Democratic candidate for president win in 2024?

### Height

Question: *What is the height of the next adult male we will meet?*

The three examples above are all *discrete* probability distributions, meaning that the outcome variable can only take on a limited set of values. A coin flip has two outcomes. The sum of a pair of dice has 11 outcomes. The total electoral votes for the Democratic candidate has 539 possible outcomes. In the limit, we can also create *continuous* probability distributions which have an *infinite* number of possible outcomes. For example, the average height for an American male could be any real number between 0 inches and 100 inches. (Of course, an average value anywhere near 0 or 100 is absurd. The point is that the average could be 68.564, 68.5643, 68.56432 68.564327, or any real number.)

All the characteristics for discrete probability distributions which we reviewed above apply just as much to continuous probability distributions. For example, we can create mathematical, empirical and posterior probability distributions for continuous outcomes just as we did for discrete outcomes.

*Mathematical distribution* is complete based on mathematical formula and assumptions like in the Flipping a coin session we assume that the coin is an perfectly fair coin where where the probability landing on heads or tails is equal. In this case, we assume that the average hight of men is 175 cm, as well as the standard deviation for height is around 9 cm. When we have these two values, the average which we also called the mean, and standard deviation (sd), we can create an normal distribution using the `rnorm()` function. And an normal distribution is an good approximation and generalization for height in our scenario.


Mathematical Distribution:

```{r}
tibble(height = rnorm(10000, mean = 175, sd = 9)) %>% 
  ggplot(aes(x = height)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                 binwidth = 1, 
                 color = "white")+
  labs(title = "Mathematical Probability Distribution",
       subtitle = "Expectations for an random male's height",
       x = "Height",
       y = "Probability") +
  scale_y_continuous(labels =
                      scales::percent_format(accuracy = 1)) +
  theme_classic()
  
```
$mean=175$
$sd=9$

Now we create an normal distribution, the histogram graph has it's most high bar near 178, which is what we set when creating the tibble for our simulated data. Again anybody can question the legitimacy of this model, and completely throw it in the trash,and one of the way to telling someone who make this graph is bad is through the *empirical distribution*.

The *empirical distribution* involves using data from the National Health and Nutrition Examination Survey (NHANES). What we are doing here is instead making an model by ourself using some mathematical formula, we use the actual data, we can get the data from either simulated by our own like in the "flipping a coin" and "Rolling two dice" scenario, or we used the data from someone else, like the presidential election and this scenario. 

```{r}
nhanes %>%
  filter(gender == "Male", age >= 18) %>%
  select(height)%>%
  drop_na() %>%
  ggplot(aes(x = height)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                 binwidth = 1, 
                 color = "white")+
  labs(title = "Empiracal Probability Distribution",
       subtitle = "Height for male by NHANES",
       x = "Height",
       y = "Probability",caption = "Source:NHANES") +
  scale_y_continuous(labels =
                      scales::percent_format(accuracy = 1)) +
  theme_classic()

```
When we graph this we can sort of seeing something similar to the mathematical graph, which tells us that the mathematical graph we create is an good approximation, but at the same time it also looks different. 


The *posterior distribution* for heights depends on the context. Are we considering all the adult men in America? In that case, our posterior would probably look a lot like the empirical distribution using NHANES data. If we are being asked about the distribution of heights among players in the NBA, then our posterior might look like:

```{r}
tibble(height = c(rep(165, 2), rep(167, 3), rep(170, 8), 
                  rep(172, 9), rep(176, 9), rep(177, 8),
                  rep(179, 10), rep(182, 18), rep(183, 23), 
                  rep(189, 20),rep(193, 21), rep(200, 15),rep(205, 15),rep(212, 8),rep(220, 4)))%>% 
    ggplot(aes(x = height)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 5, 
                   color = "white")+
    labs(title = "Posterior Probability Distribution",
         subtitle = "One's belief about NBA baskectball players",
         x = "Height",
         y = "Probability") +
    scale_y_continuous(labels =
                           scales::percent_format(accuracy = 1)) +
    theme_classic()
  
```

In general when we think about the difference between these three distributions, we can think about the mathematical as completely theoretical, imagine we only have an paper and a pencil, and we were ask to create a model, that model is basically the *mathematical distributions*. *Empirical distribution* on the other hand is different, empirical distribution is completely based on data, there is no such thing as writing down formula or equation and coming up with a distribution based on that, we come up *empirical distribution* by analyzing data, you can think of empirical distribution as someone flip a coin 1000 times, and we record the data and creating a graph based on that. Last but not least, *Posterior distribution* this graph represents one's belief about certain situation, for example when we think about flipping a coin, our mathematical and empirical results would likely look similar, and if there is no other assumption our posterior should also looks similar, but if were in a casino, and someone tells you that they want to bet 100 bucks on head and you bet 100 bucks on tail, who wins we get's all the money. Now you maybe suspicious, you won't likely to trust this person who is convincing you to bet, now the *posterior distribution* could help you to visualize and quantified your beliefs which is extremely helpful when making decision. 

In short:
* Mathematical distribution is based on mathematical formula and some basic assumptions
* Empirical distribution is based on data, the data could eigther done by yourself or somebody else.
* Posterior distribution is based on belief, the belief is usually shaped by added information about the scenario. 

<!-- DK: Insert here mathematical, empirical and posterior examples. -->

Comments:

<!-- Need X Files poster -->


```{r, echo = FALSE, fig.cap = "The truth is out there"}
knitr::include_graphics("05-probability/images/truth_out_there.jpg")
```
 

* *The truth is out there.* If we asked all 300+ million Americans whether or not they approve of President Biden, we could know $p$ exactly. Alas, we can't do that. We use a posterior probability distribution to summarize are beliefs about the true value of $p$, a truth we can never confirm.

* *Continuous variables are a myth.* Nothing that can be represented on a computer is [truly continuous](https://cs.stackexchange.com/questions/71648/why-is-data-in-computer-science-considered-to-be-discrete). Even something which appears continuous, like $p$, actually can only take on a (very large) set of discrete variables. In this case, there are approximately 300 million possible true values of $p$, one for each total number of people who approve of President Biden.

* The math of continuous probability distributions can be tricky. Read [a book](https://drive.google.com/file/d/1VmkAAGOYCTORq1wxSQqy255qLJjTNvBI/view) on  mathematical probability for all the messy details. Little of that matters in applied work.

* The most important difference is that, with discrete distributions, it makes sense to estimate the probability of a specific outcome. What is the probability of rolling a 9? With continuous distributions, this makes no sense because there are an infinite number of possible outcomes. *With continuous variables, we only estimate intervals.* 

<!-- DK: This is important. Give an example. Answer the question. -->

Don't worry about the distinctions between discrete and continuous outcomes, or between the discrete and continuous probability distributions which we will use to summarize our beliefs about those outcomes. The basic intuition is the same in both cases.


### Unnormalized distributions

Remember that *probability distributions are mathematical objects that cover a set of outcomes, where each outcome in the domain is mapped to a probability value between 0 and 1 inclusive and the sum of all mappings is 1.* Sometimes, you may see distributions similar to probability distributions, only the y-axis displays raw counts instead of proportions. Unnormalized distributions are not probability distributions, but it is easy to convert between the two. You simply divide all the outcome counts on the y-axis by the sum of all outcome counts to "normalize" the unnormalized distribution. Unnormalized distributions are often an intermediary step; it is sometimes handy to work with counts until the very end.

<!-- DK: Do we really need this?  -->

For instance, we can generate the following unnormalized distribution for the sum of rolling two dice. (This uses the same code as above, but without the normalization step.)

```{r, echo = FALSE}
set.seed(1)

tibble(ID = 1:100) %>% 
  mutate(die_1 = map_dbl(ID, ~ sample(c(1:6), size = 1))) %>% 
  mutate(die_2 = map_dbl(ID, ~ sample(c(1:6), size = 1))) %>% 
  mutate(sum = die_1 + die_2) %>% 
  ggplot(aes(x = sum)) +
    geom_histogram(binwidth = 1, color = "white") +
    labs(title = "Empirical Unnormalized Distribution",
         subtitle = "Sum from rolling two dice one hundred times",
         x = "Outcome\nSum of Two Die",
         y = "Count") +
    scale_x_continuous(breaks = seq(0, 12, 1), labels = 0:12) +
    theme_classic()
```

Notice that the shape of the distribution is the same as the empirical probability distribution we generated earlier, except that the y-axis is labeled differently.

```{r, echo = FALSE}
emp_dist_dice
```


The two plots --- unnormalized and normalized --- have the exact same shape. In many ways, they are the same object. Yet normalization is required if we want to work with a probability distribution.


### Joint distributions

<!-- DK: Should be p(A). Discuss p(A, B). Find a better example.  -->

Recall that $\text{Prob}(\text{coin})$ is the probability distribution for the result of a coin toss. It includes two parts, the probability of heads ($\rho_h$) and the probability of tails ($\rho_t$). This is a *univariate* distribution because there is only one outcome, which can be heads or tails. If there is more than one outcome, then we have a *joint* distribution.

<!-- DK: Use of "outcome" is sloppy. Does a single die roll have one outcome or 6? -->

Joint distributions are also mathematical objects that cover a set of outcomes, where each distinct outcome has a chance of occurring between 0 and 1 and the sum of all chances must equal 1. The key to a joint distribution is it measures the chance that both events A and B will occur. The notation is $\text{Prob}(A, B)$.

Let's say that you are rolling two six-sided dice simultaneously. Die 1 is weighted so that there is a 50% chance of rolling a 6 and a 10% chance of each of the other values. Die 2 is weighted so there is a 50% chance of rolling a 5 and a 10% chance of rolling each of the other values. Let's roll both dice 1,000 times. In previous examples involving two dice, we cared about the sum of results and not the outcomes of the first versus the second die of each simulation. With a joint distributions, the order matters; so instead of 11 possible outcomes on the x-axis of our distribution plot (ranging from 2 to 12), we have 36. Furthermore, a 2D probability distribution is not sufficient to represent all of the variables involved, so the joint distribution for this example is displayed using a 3D plot.

```{r, echo = FALSE}
# DK: Revisit and clean up this code.

# Step 1: Create and organize the data.

mydata <- tibble(die.1 = sample(1:6, size = 1000, prob =
                                  c(0.1,0.1,0.1,0.1,0.1,0.5), replace = TRUE),
                 die.2 = sample(1:6, size = 1000, prob =
                                  c(0.1,0.1,0.1,0.1,0.5,0.1), replace = TRUE)) %>%
          group_by(die.1, die.2) %>%
          summarize(total = n(),
                    .groups = "drop")

die1_factor <- as.factor(mydata$die.1)
die2_factor <- as.factor(mydata$die.2)


# Step 2: Create a ggplot object.

mtplot <-  ggplot(mydata) +
              geom_point(aes(x = die1_factor, y = die2_factor, color = total)) +
              scale_color_continuous(limits = c(0,100)) +
              labs(x = "Die 1", y = "Die 2") +
              theme(legend.position = "none")


# Step 3: Turn it into a 3D plot. This takes a bit of time and
# will open an interactive "RGL Device" window with the plot.

plot_gg(mtplot,
        width = 3.5, # Plot width
        zoom = 0.65, # How close view on plot should be (1=normal, <1=closer)
        theta = 25, # From which direction to view plot (0-360°)
        phi = 30, # How "steep" view on plot should be (0-90°)
        sunangle = 225, # Angle of sunshine for shadows (0-360°)
        soliddepth = -50, # Thickness of pane (always <0, the smaller the thicker)
        windowsize = c(2048,1536)) # Resolution
Sys.sleep(0.2)

# Step 4: Embed plot in Rmd file.

rglwidget()


# Step 5: Close the "RGL Device" window by running this command. Do
# this EVERY time before you try to create a new 3D plot.

rgl.close()
```

### Working with probability distributions


<!-- DK: Does this really belong here? Maybe at the end? -->

```{r, echo = FALSE, out.width="60%", fig.align='center', fig.cap = 'Bruno de Finetti, an Italian statistician who wrote a famous treatise on the theory of probability that began with the statement "PROBABILITY DOES NOT EXIST." This is because probability only exists subjectively in our minds.'}

knitr::include_graphics("05-probability/images/de_finetti.jpg")

```

A probability distribution is not always easy to work with. It is a complex object. And, in many contexts, we don't really care about all that complexity. So, instead of providing the full probability distribution, we often just use a summary measure, a number or two or three which captures those aspects of the entire distribution which are relevant to the matter at hand. Let's explore these issues using the 538 posterior probability distribution, as of August 13, 2020, for the number of electoral votes which will be won by Joe Biden. Here is a tibble with 1,000,000 draws from that distribution:


```{r, echo = FALSE}
# DK: This code is a mess! Please fix!

z <- read_csv("https://raw.githubusercontent.com/PPBDS/primer/master/05-probability/data/election-forecasts-2020/prez_1.csv", 
              col_types = cols(cycle = col_double(),
                               branch = col_character(),
                               model = col_character(),
                               modeldate = col_character(),
                               candidate_inc = col_character(),
                               candidate_chal = col_character(),
                               candidate_3rd = col_logical(),
                               evprob_inc = col_double(),
                               evprob_chal = col_double(),
                               evprob_3rd = col_logical(),
                               total_ev = col_double(),
                               timestamp = col_character(),
                               simulations = col_double()
                               )) %>%
       select(evprob_chal, total_ev)  %>% 
       rename(prob = evprob_chal, electoral_votes = total_ev) %>% 
       mutate(obs = round(prob * 1000000))  %>% 
       select(-prob) %>% 
       uncount(weights = obs) %>% 
       pull(electoral_votes)



draws <- tibble(ID = 1:1000000,
                electoral_votes = as.integer(sample(z)))                     
                          
```

```{r}
draws
```

*A distribution and a sample of draws from that distribution are different things.* But, if you squint, they are sort of the same thing, at least for our purposes. For example, if you want to know the mean of the distribution, then the mean of the draws will be a fairly good estimate, especially if the number of draws is large enough.

<!-- DK: Need more here. Connect to the discussion in Section 2.9 -->

Recall from Chapter \@ref(wrangling) how we can draw randomly from specified probability distributions:

```{r}
rnorm(10)
```

```{r}
runif(10)
```

The elements of these vectors are all "draws" from the specified probability distributions. In most applied situations, our tools will produce draws rather than summary objects. Fortunately, a vector of draws is very easy to work with. Start with summary statistics:


```{r}
key_stats <- draws %>% 
  summarize(mn = mean(electoral_votes),
            md = median(electoral_votes),
            sd = sd(electoral_votes),
            mad = mad(electoral_votes))

key_stats
```


Calculate a 95% interval directly:

```{r}
quantile(draws$electoral_votes, probs = c(0.025, 0.975))
```

Approximate the 95% interval in two ways:

```{r}
c(key_stats$mn - 2 * key_stats$sd, 
  key_stats$mn + 2 * key_stats$sd)
c(key_stats$md - 2 * key_stats$mad, 
  key_stats$md + 2 * key_stats$mad)
```

In this case, using the mean and standard deviation produces a 95%  interval which is closer to the true interval. In other cases, the median and scaled median absolute deviation will do better. Either approximation is generally "good enough" for most work. But, if you need to know the exact 95% interval, you must use `quantile()`.



## Tree diagrams

<!-- DK: Worth rewriting? Yes! Tie it better to above and below. Not sure we even need tree diagrams. What are we trying to teach here? -->

### Independence

So far, you have learned how to explore $\text{Prob}(A)$, which is the fancy, statistical way of saying the probability distribution for event A. Keep in mind the distinction between an individual outcome from the set $A$, like the probability of heads (which is $\rho_h$) and the entire distribution $\text{Prob}(\text{coin})$, which includes the probability of each possible outcomes.  $\text{Prob}(A)$ is like $\text{Prob}(\text{coin})$ or $\text{Prob}(\text{sum of two dice})$.

What if you flipped two coins in a row, one after the other? You know that the probability of getting heads on the first coin is 1/2. But what are the odds of getting heads two times in a row? Let's take a look at this tree diagram. We read this diagram from left to right. On the left, the probability of getting heads is 0.5 on the first toss. Then, the tree branches out.

* *If* we got heads the first time, then we go up the top branch. The probability of getting heads again is 0.5.
* *If* we got tails the first time, then we go down the bottom branch. The probability of getting heads is 0.5.


Notice how regardless of what we get the first time we flip the coin, the probability of getting heads is 0.5 throughout. Coin flips, in this scenario, are **independent**. The result of one coin flip does not impact the next coin flip. 

<!-- DK: Should we create these decision trees on the fly, perhaps using https://github.com/malcolmbarrett/ggdag  or maybe straight dagitty? For now, what we have is fine. -->

```{r, echo = FALSE}
knitr::include_graphics("05-probability/images/tree-1.png")
```

### Conditional probability

Imagine that 60% of people in a community have a disease. A doctor develops a test to determine if a random person has the disease. However, this test isn't 100% accurate. There is an 80% probability of correctly returning positive **if the person has the disease** and 90% probability of correctly returning negative **if the person does not have the disease**.

The probability of a random person having the disease is 0.6. Since each person either has the disease or doesn't (those are the only two possibilities), the probability that a person does not have the disease is $1 - 0.6 =  0.4$.

```{r, echo = FALSE}
knitr::include_graphics("05-probability/images/tree-2.png")
```

Now the tree branches out.

* *If* the random person has the disease, then we go up the top branch. The probability of an infected person testing positive is 0.8 because the test is 80% sure of correctly returning positive when the person has the disease.
* By the same logic, *if* the random person does not have the disease, we go down the bottom branch. The probability of the person incorrectly testing positive is 0.1.

We decide to go down the top branch *if* our random person has the disease. We go down the bottom branch *if* they do not. This is called **conditional probability**. The probability of testing positive is **dependent** on whether the person has the disease.

How would you express this in statistical notation? $\text{Prob}(A|B)$ is the same thing as the probability of A *given* B. $\text{Prob}(A|B)$ essentially means the probability of A *if* we know for sure the value of B. Note that $\text{Prob}(A|B)$ is not the same thing as $\text{Prob}(B|A)$.


<!-- DK: The above write up is not impressive. What are we trying to accomplish? Also, we might add some simple coding/simulation examples to illustrate these points.  -->


## Two models

<!-- Consider the parallel structure of the 2-model, 3-model, and n-model case. First, we  begin by discussing how to create the joint distribution of possible models and possible experimental results. This is done by, first, assuming that one of the models is true and then, second, show the variation in the world which results. That is, even if we know for a fact that you do not have the disease, there is still a chance that you test will come back positive.

 Then, we create the joint distribution by doing that same thing for all possible models. (We show all this code.) The joint distribution is a tibble which we are happy to look at. It always has two columns: the first is the possible models (have disease) and the second is one possible result (test_positive) if that model is true. And that each possible model have at least 1,000 rows in the joint distribution.. -->


<!-- Having create the joint distribution, we graph it in two dimensions. (We show the code for that.) Then, we graph it in three dimensions with rayshader. (We have a rough movie.) Then, we take a "slice" of that joint distribution via rayshader (Have the movie but needs improvement). Move that slice around. Et cetera. Not sure how to do all that . . . Note that you can make rayshader objects interactive with rgl::rglwidget(). The ggral (sp?) package might also be useful (Did not use ggral yet to create rayshader 3D). -->

<!-- After rayshader, we then use the joint distribution to make two graphics, showing the posterior distribution for the model. The first is unnormalized and the second is normalized. In both cases, we begin with the joint distribution --- an object we have saved --- and then use filter to get our slice. Both graph and unromalized and normalized were made in 2D, could considered using rayshader/movie. -->

The simplest possible setting for inference involves two models --- meaning two possible states of the world --- and two outcomes from an experiment. Imagine that there is a disease --- *Probophobia*, an irrational fear of probability --- which you either have or don't have. We don't know if you have the diseases, but we do assume that there are only two possibilities. 

We also have a test which is 50% accurate when giving test to an person who have *Probophobia*, and 99% accurate for people who don't. This is our experiment, one with only two possible outcomes: positive and negative. 

Question: *If you test positive, what is the probability that you have Probophobia?*

More generally, we are estimating a *conditional probability*. Conditional on the outcome of a postive test, what is the probability that you have Probophobia? Mathematically, we want:

$$ \text{Prob}(\text{Disease | Test = Postive} ) $$


To answer this question, we need to use the tools of joint and conditional probability that we have learned earlier in this Chapter. We begin by building, by hand, the joint distribution of the possible models (you have the Probophobia or you do not) and of the possible outcomes (you test positive or negative). Building the joint distribution involves *assuming* that each model is true and then creating the distribution of outcomes which might occur if that assumption is true. 

For example, assume you have Probophobia. There is then a 50% chance that you test positive and a 50% chance you test negative. Similarly, if we assume that the second model is true --- that you don't have Probophobia --- then there is 1% chance you test positive and a 99% you chance negative. Of course, for you (or any individual) we do not know for sure what is happening. We do not know if you have the disease. We do not know what your test will show. But we can use these relationships to construct the joint distribution.


```{r, echo = FALSE}
set.seed(9)
```


```{r}
# Pipes generally start with tibbles, so we start with a tibble which just
# includes an ID variable. We don't really use ID. It is just handy for getting
# organized. We call this object `jd_disease`, where the `jd` stands for
# joint distribution.

jd_disease <- tibble(p = rep(seq(0.01, 0.5, 0.49), 10000)) %>%
  mutate(disease = map_int(p, ~ rbinom(n = 1, size = 1, p = .)))


jd_disease
```

The first step is to simply create an tibble that consists of the simulated data we need to plot our distribution. Keep in mind that in the setting we have two different probabilities and they are completely separate from each other and we want to keep the two probabilities and the disease results in two and only two columns so that we can graph using the `ggplot()` function. And that's why we used the `rep` and `seq` functions when creating the table, we used the `seq` function to set the sequence we wants, in this case is only two numbers, 0.01 (99% accuracy for testing negative if no disease, therefore 1% for testing positive if no disease) and 0.5 (50% accuracy for testing positive/negative if have disease), then we used the `rep` functions to repeat the process 10,000 times for each probability, in total 20,000 times. Note that this number "20,000" also represent the population in our simulated data, we simulated 20,000 results from testing, where 10,000 results from the have-disease group and 10,000 for the no-disease group, we often use the capital N to represent the population, in this simulated data N=20,000.

Plot the joint distribution:

```{r}
jd_disease %>% 
  ggplot(aes(x = as.factor(disease), 
             y = as.factor(p))) +
  geom_point() +
  geom_jitter(alpha = .2) +
  labs(title = "Unnormalized Distribution of Test Results and Disease Status",
       subtitle = "Many False results in have disease than no disease",
       x = "Test Result",
       y = "Disease Status") +
  scale_x_discrete(breaks = c(0,1), 
                   labels = c("Negative", "Positive")) +
  scale_y_discrete(breaks = c(0.01, 0.5), 
                   labels = c("No Disease", "Have Disease")) +
  theme_classic()
```

Below is a joint distribution displayed in 3D. Instead of using the "jitter" feature in R to unstack the dots, we are using a 3D plot to visualize the number of dots in each box. The number of people who correctly test negative is far greater than of the other categories. The 3D plot shows the total number of cases for each section (True positive, True negative, False positive, False negative),the 3D bar coming from those combinations. Now,pay attention to the two rows of the 3D graph, if you trying to add up the length of the 3D bar for the top two sections and the bottom two sections, they should be equal to each other, where each have 10,000 case. This is because we simulate the experience in two independent and separate world one in the have-disease world and one in the no-disease world.


```{r, echo = FALSE}

jd_disease_plot <- jd_disease %>%
  group_by(p, disease) %>%
  summarize(total = n(),
            .groups = "drop") %>% 
  ggplot(aes(x = as.factor(disease),
             y = as.factor(p),
             color = total)) +
    geom_point(size = 5) +
    scale_x_discrete(breaks = c(0, 1),
                     labels = c("Negative", "Positive")) +
    scale_y_discrete(breaks = c(0.01, 0.5),
                     labels = c("No Disease", "Have Disease")) +
    labs(x = "Test Result",
         y = "Disease Status",
         title = "Unnormalized Distribution of Results and Status",
         subtitle = "Many False results in have disease than no disease",
         color = "Cases") +
    theme_classic() +
    theme(legend.position = "none",
          title = element_text(size = 7),
          axis.text.x = element_text(size = 7),
          axis.text.y = element_text(size = 7))

plot_gg(jd_disease_plot,
        width = 3.5,
        zoom = 0.65,
        theta = 25,
        phi = 30,
        sunangle = 225,
        soliddepth = -50,
        windowsize = c(2048,1536))

rglwidget()

rgl.close()
```

<!-- DK: Insert the sliced rayshader distribution here, and discuss. Then, below, we do the same thing by hand. Then, use this text: -->

<!-- If we zoom in on the plot, FIX THIS people who tested positive have the disease and FIX THIS who tested positive do not have the disease. In this case, we are focusing on one slice of the probability distribution where the test result was positive. There are two disease outcomes: positive or negative. By isolating a section, we are looking at a conditional distribution. Conditional on a positive test, you can visualize the likelihood of actually having the disease versus not. -->

This Section is called "Two Models" because, for each person, *there are two possible states of the world: have the disease or not have the disease.* By assumption, there are no other outcomes. We call these two possible states of the world "models," even though they are very simple models.

In addition to the two models, we have two possible results of our experiment on a given person: test positive or test negative. Again, this is an assumption. We do not allow for any other outcome. In coming sections, we will look at more complex situations where we consider more than two models and more than two possible results of the experiment. In the meantime, we have built the *unnormalized joint distribution for models and results*. This is a key point! Look back earlier in this Chapter for discussions about both unnormalized distributions and joint distributions. 

We want to analyze these plots by looking at different slices. For instance, let's say that you have tested positive for the disease. Since the test is not always accurate, you cannot be 100% certain that you have it. We isolate the slice where the test result equals 1 (meaning positive). 


```{r}
jd_disease %>% 
  filter(disease == 1)
```

**Most people test positive are infected** This is a result for common diseases like cold. We can easily create an unnormalized conditional distribution with:

```{r}
jd_disease %>% 
  filter(disease == 1) %>% 
  ggplot(aes(p)) +
    geom_bar() +
    labs(title = "Disease Status Given Positive Test",
         subtitle = "Almost all of the cases were infected",
         x = "Disease Status",
         y = "Count") +
    scale_x_continuous(breaks = c(0.01, 0.5),
                       labels = c("Healthy", "Infected")) +
  theme_classic()
```

*`filter()` transforms a joint distribution into a conditional distribution.*

Turn this unnormalized distribution into a posterior probability distribution:


```{r}
jd_disease %>% 
  filter(disease == 1) %>% 
  ggplot(aes(p)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.25, 
                   color = "white") +
    labs(title = "Posterior for Probophobia Conditional on Positive Test",
         x = "Probophobia Status",
         y = "Probability") +
    scale_x_continuous(breaks = c(0.01, 0.5),
                       labels = c("Healthy", "Infected")) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()  
```

Now recalled the question we asked at the start of the session:
*If you test positive, what is the probability that you have Probophobia?*

By looking at the posterior graph we just create, we can answer this question easily:
*With a positive test, you can be almost 100% sure that you have Probophobia.*

<!-- DK: Insert a use of this posterior? How many positive tests before you have at least 10 sick people? -->


This Stat 110 Animations video does a really good job of explaining similar concepts.

```{r, echo = FALSE}
knitr::include_app("https://www.youtube.com/embed/by3_weGwnMg")
```

## Three models

<!-- DK: Should this be in terms of p or number of white marbles or both? -->

```{r, echo = FALSE}
knitr::include_graphics("05-probability/images/marble.jpg")
```

Imagine that your friend gives you a bag with two marbles. There could either be two white marbles, two black marbles, or one of each color. Thus, the bag could contain 0% white marbles, 50% white marbles, or 100% white marbles. Respectively, the proportion, $p$, of white marbles could be 0, 0.5, or 1.

Question: *What is the chance of the bag contains exactly two white marbles, given that when we selected the white marbles three times, everytime we select a white marble?*

$$ \text{Prob}(\text{2 Marbles in bag | White Marble Select=3} ) $$
Just as during the *Probophobia* models, in order to answer this question, we need to start up with the simulated data and then graphing out the joint distribution of this sinerio because we need to considered all possible outcomes of this model, and then based on the joint distribution we can slice out the the part we want (Conditional distribution) in the end making an posterior graph as well as normalizing it to see the probability.

Step 1: Simulate the data into an tibble

Let's say you take a marble out of the bag, record whether it's black or white, then return it to the bag. You repeat this three times, observing the number of white marbles you see out of three trials. You could get three whites, two whites, one white, or zero whites as a result of this trial. We have three models (three different proportions of white marbles in the bag) and four possible experimental results. Let's create 3,000 draws from this joint distribution:

```{r}
# Create the joint distribution of the number of white marbles in the bag
# (in_bag) and the number of white marbles pulled out in the sample (in_sample),
# one-by-one. in_bag takes three possible values: 0, 1 and 2, corresponding to
# zero, one and two white marbles potentially in the bag.

sims <- 10000

# We also start off with a tibble. It just makes things easier

jd_marbles <- tibble(ID = 1:sims) %>% 
  
  # For each row, we (randomly!) determine the number of white marbles in the
  # bag. We do not know why the `as.integer()` hack is necessary. Shouldn't
  # `map_int()` automatically coerce the result of `sample()` into an integer?
  
  mutate(in_bag = map_int(ID, ~ as.integer(sample(c(0, 1, 2), 
                                                  size = 1)))) %>%
  
  # Depending on the number of white marbles in the bag, we randomly draw out 0,
  # 1, 2, or 3 white marbles in our experiment. We need `p = ./2` to transform
  # the number of white marbles into the probability of drawing out a white
  # marble in a single draw. That probability is either 0%, 50% or 100%.
  
  mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1, 
                                              size = 3, 
                                              p = ./2))) 

jd_marbles
```

Step 2: Plot the joint distribution:

```{r}
# The distribution is unnormalized. All we see is the number of outcomes in each
# "bucket." Although it is never stated clearly, we are assuming that there is
# an equal likelihood of 0, 1 or 2 white marbles in the bag.

jd_marbles %>%
  ggplot(aes(x = in_sample, y = in_bag)) +
    geom_jitter(alpha = 0.5) +
    labs(title = "Black and White Marbles",
         subtitle = "More white marbles in bag mean more white marbles selected",
         x = "White Marbles Selected",
         y = "White Marbles in the Bag") +
    scale_y_continuous(breaks = c(0, 1, 2)) +
  theme_classic()

```

Here is the 3D visualization:

```{r, echo = FALSE}
jd_marbles_plot <- jd_marbles %>%
  group_by(in_bag, in_sample) %>%
  summarize(total = n(),
            .groups = "drop") %>% 
  mutate(in_sample = as.factor(in_sample)) %>% 
  mutate(in_bag = as.factor(in_bag)) %>% 
  ggplot(aes(x=in_sample, y=in_bag, color = total)) +
    geom_point() +
    scale_color_continuous() +
    labs(x = "White Marbles Selected",
         y = "White Marbles in the Bag",
         title = "Black and White Marbles",
         subtitle = "More white marbles in bag mean more are selected",
         color = "Count") +
    theme(legend.position = "none",
          title = element_text(size = 7),
    axis.text.x = element_text(size = 6),
    axis.text.y = element_text(size = 6))

plot_gg(jd_marbles_plot,
        width = 3.5,
        zoom = 0.65,
        theta = 25,
        phi = 30,
        sunangle = 225,
        soliddepth = -50,
        windowsize = c(2048,1536))

rglwidget()

rgl.close()
```



The y-axes of both the scatterplot and the 3D visualization are labeled "Number of White Marbles in the Bag." *Each value on the y-axis is a model, a belief about the world.* For instance, when the model is 0, we have no white marbles in the bag, meaning that none of the marbles we pull out in the sample will be white.

Now recalls the question, we essentially only care about the fourth column in the joint distribution (x-axis=3) because the question is asking us to create a conditional distribution *given* that fact that 3 marbles were selected. Therefore, we could isolate the slice where the result of the simulation involves three white marbles and zero black ones. Here is the unnormalized probability distribution.

Step 3: Plot the unnormalized conditional distribution.

```{r}
# The key step is the filter. Creating a conditional distribution from a joint
# distribution is the same thing as filtering that joint distribution for a
# specific value. A conditional distribution is a "slice" of the joint
# distribution, and we take that slice with filter().

jd_marbles %>% 
  filter(in_sample == 3) %>% 
  ggplot(aes(in_bag)) +
    geom_histogram(binwidth = 0.5, color = "white") +
    labs(title = "Unnormalized Conditional Distribution",
         subtitle = "Number of white marbles in bag given that three were selected in the sample",
         x = "Number of White Marbles in the Bag",
         y = "Count") +
    coord_cartesian(xlim = c(0, 2)) +
    scale_x_continuous(breaks = c(0, 1, 2)) +
    theme_classic()

```

Step 4: Plot the normalize posterior distribution.
Next, let's normalize the distribution.

```{r}
jd_marbles %>% 
  filter(in_sample == 3) %>% 
  ggplot(aes(in_bag)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.5, 
                   color = "white") +
    labs(title = "Posterior Probability Distribution",
         subtitle = "Number of white marbles in bag given that three were selected in the sample",
         x = "Number of White Marbles in the Bag",
         y = "Probability") +
    coord_cartesian(xlim = c(0, 2)) +
    scale_x_continuous(breaks = c(0, 1, 2)) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()

```

This plot makes sense because when all three marbles you draw out of the bag are white, there is a pretty good chance that there are no black marbles in the bag. But you can't be certain! It is possible to draw three white even if the bag contains one white and one black. However, it is impossible that there are zero white marbles in the bag.

Lastly let's answer the question:
*What is the chance of the bag contains exactly two white marbles, given that when we selected the white marbles three times, everytime we select a white marble?*

Answer:
*As the Posterior Probability Distribution shows (x-axis=2), the chance of the bag contains exactly two white marbles given that we select 3 white marbles out of three tries is about 85%.*


## N models

<!-- 5 a) Now go on to Rethinking approach. I think that chapter 2 is just genius. Bayesian is really just counting. Maybe we do a very similar example to what he does? Maybe different? I am still pondering this myself. I think that there is a deep relationship here. In the simple Bayes rule decision trees, we know all the probabilities. But what if we don't? Instead, we get to observe lots of data (which are counts!) and then, from that data, figure out the probabilities. (Note that Rethinking does not talk like this --- after all, we know all the probabilities since each marble has a 20% chance of being drawn --- but I think it is implicit in his approach.) Key issue: Can we connect this in a sensible way to Bayesian scatterplot. There is always the data and the model and the relationship between the two. (And "the model" means, mainly, the parameter estimates thereof.) Tell me the data, and I will tell you the model. Tell me the model, and I will tell you the model. -->

<!-- Note the connection between the marbles from Rethinking and the Bayesian scatterplot. In figure 2.2 in Rethinking represents the model where p = 0.25, where p is the proportion of blue marbles in the total collection. The y-axis models would be labeled with p = 0, 0.25, 0.5, 0.75, and 1. With the tree marble diagram in figure 2.2, we would be taking random samples with 3 marbles. The number of blue marbles we get each time would be plotted along p = 0.25. This is another example of model on the y-axis and data on the x-axis. -->

<!-- DK: Should we cut out p = 0 and p = 1 as too annoying to deal with? -->

```{r, echo = FALSE}
knitr::include_graphics("05-probability/images/heads.jpg")
```

Assume that there is a coin with $\rho_h$. We guarantee that there are only 11 possible values of $\rho_h$: $0, 0.1, 0.2, ..., 0.9, 1$. In other words, there are 11 possible models, 11 things which might be true about the world. This is just like situations we have previously discussed, except that there are more models to consider.

We are going to run an experiment in which you flip the coin 20 times and record the number of heads. What does this result tell you about the value of $\rho_h$? Ultimately, we will want to calculate a posterior distribution of $\rho_h$, which is written as p($\rho_h$). 

Question: *What most likely be probability of a certain coin for getting exactly 8 heads out of 20 tosses. ?*

To start, it is useful to consider all the things which might happen if, for example, $\rho_h = 0.4$. Fortunately, the R functions for simulating random variables makes this easy.

```{r, echo = FALSE}

set.seed(9)
x <- tibble(heads = rbinom(n = 1000, size = 20, p = 0.4)) 

x %>% 
  ggplot(aes(heads)) +
    geom_histogram(aes(y = after_stat(count/sum(count))),
                   bins = 50) + 
    labs(title = "Empirical Distribution of Number of Heads",
         subtitle = "Based on 1,000 simulations with p = 0.4",
         x = "Number of Heads out of 20 Tosses",
         y = "Probability") +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
  theme_classic()

```

First, notice that many different things can happen! Even if we *know*, for certain, that $\rho_h = 0.4$, many outcomes are possible. Life is remarkably random. Second, the most likely result of the experiment is 8 heads, as we would expect. Third, we have transformed the raw counts of how many times each total appeared into a probability distribution. Sometimes, however, it is convenient to just keep track of the raw counts. The shape of the figure is the same in both cases.

```{r, echo = FALSE}

x %>%
  ggplot(aes(heads)) +
     geom_histogram(bins = 50) + 
    labs(title = "Total Count of the Number of Heads Out of 20 Tosses",
         subtitle = "Based on 1,000 simulations with p = 0.4",
         x = "Number of Heads out of 20 Tosses",
         y = "Count") +
  theme_classic()

```

Either way, the figures show what would have happened if that model --- that $\rho_h = 0.4$ --- were true.

We can do the same thing for all 11 possible models, calculating what would happen if each of them were true. This is somewhat counterfactual since only one of them can be true. Yet this assumption does allow us to create the *joint distribution* of *models which might be true* and of *data which our experiment might generate*. Let's simplify this is p(models, data), although you should keep the precise meaning in mind.

```{r, echo = FALSE}

set.seed(10)

jd_coin <- tibble(p = rep(seq(0, 1, 0.1), 1000)) %>%
  mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .)))

jd_coin %>%
  ggplot(aes(y = p, x = heads)) +
    geom_jitter(alpha = 0.1) +
    labs(title = "Empirical Distribution of Number of Heads",
         subtitle = expression(paste("Based on simulations with various values of ", rho[h])),
         x = "Number of Heads out of 20 Tosses",
         y = expression(rho[h])) +
  scale_y_continuous(breaks = seq(0, 1, 0.1)) +
  theme_classic()

```

Here is the 3D version of the same plot.

```{r, echo = FALSE}
jd_coin_plot <- jd_coin %>% 
  group_by(p, heads) %>%
  summarize(total = n(), .groups = "drop") %>% 
  mutate(p = as.factor(p)) %>% 
  mutate(heads = as.factor(heads)) %>% 
  ggplot() +
    geom_point(aes(x = heads, y = p, color = total)) +
    theme(legend.position = "none") +
    labs(x = "Number of Heads out of 20 Tosses",
         y = expression(rho[h]),
         title = "Empirical Distribution of Number of Heads",
         subtitle = expression(paste("Based on simulations with various values of ", 
                                     rho[h]))) +
    theme(title = element_text(size = 9),
          axis.text.x = element_text(size = 7),
          axis.title.y = element_text(size = 7),
          legend.position = "none")

plot_gg(jd_coin_plot,
        width = 3.5,
        zoom = 0.65,
        theta = 25,
        phi = 30,
        sunangle = 225,
        soliddepth = -50,
        windowsize = c(2048,1536))

rglwidget()

rgl.close()
```

In both of these diagrams, we see 11 models and 21 outcomes. We don't really care about the p($models$, $data$), the joint distribution of the models-which-might-be-true and the data-which-our-experiment-might-generate. Instead, we want to estimate $p$, the unknown parameter which determines the probability that this coin will come up heads when tossed. The joint distribution alone can't tell us that. We *created* the joint distribution before we had even conducted the experiment. It is our creation, a tool which we use to make inferences. Instead, we want the conditional distribution, p($models$ | $data = 8$). We have the results of the experiment. What do those results tell us about the probability distribution of $p$? 

To answer this question, we simply take a vertical *slice* from the joint distribution at the point of the x-axis corresponding to the results of the experiment.


This animation shows what we want to do with joint distributions. We take a slice (the red one), isolate it, rotate it to look at the conditional distribution, normalize it (change the values along the current z-axis from counts to probabilities), then observe the resulting posterior.

<!-- 

TW: I tried to recreate the GIF below in rayshader, but failed. For those bold enough to try, the process 
to create it would be as follows (problem described at the end):


1. Create a dataframe with three columns: x, y and z. These will be the coordinates. 
   Note that you need to cover every possible combination of x and y-values, and 
   every such combination must have a z-value. Thus, the dataframe should have 
   3 * [(#x-values)*(#values)] observations. Creating this by hand is a tedious process, 
   but if you are using the same series of z-values over and over again, MS Excel might 
   be helpful. 
   If you want to save time, check out the file Values.xlsx in primer/05-probability. It
   contains a dataframe I created, but it does not have the exact same dimensions as the plot 
   in the GIF.
   
   
2. Create a 2D plot like this and and save it as an object.
    
plot <-- ggplot(df, aes(x, y, color = z)) +
          geom_point() +
          theme(legend.position = "none")
   
   
3. Turn it into a 3D plot. Use the following code. Only the first
   argument is required, you may adjust the rest.

plot_gg(plot,
        width = 3.5,
        zoom = 0.65,
        theta = 25,
        phi = 30,
        sunangle = 225,
        soliddepth = -50,
        windowsize = c(2048,1536))


4. If you installed xquartz, and window named "RGL Device" with the plot 
   should have opened on your machine. Tilt the plot in the desired position.
   Then, run this command to create a snapshot:
   
render_snapshot()

   Congrats, you now have a single snapshot. However, keep in mind that in order to 
   create a GIF, you need a series of snapshots that can be rendered into a GIF. This
   means you will have to repeat the above process for every possible perspective/plot 
   seen in below. And since the GIF consist of different plots, you must not only change
   the perspective, but also the plot itself when creating all those snapshots. As I see it, 
   there are four different plots that would need to be created:
    
    - "edge view" and all blue (initial view / one snapshot)
    - "edge view" and one distribution red (one snapshot)
    - "edge view" and all but red distribution flat (one snapshot) 
    - shift to a frontal 2D-like perspective (many snapshots)
   
   The last step can (and should) be automated. This involves writing a loop that changes the 
   view on the plot just a little bit, creates a snapshot, moves on to the next position, creates
   another snapshot, and so on. This is not as hard as it seems, and a basic example of this can
   be found here https://www.tylermw.com/a-step-by-step-guide-to-making-3d-maps-with-satellite-imagery-in-r/
   (scroll down to the last image).
   

5. Once you have created all the snapshots the GIF will consist of, make sure their names reflect
   the order in which they should be displayed. For example, "plot1.png", "plot2.png" and so on. If
   you write the loop the right way, you may only have to rename the first three snapshots created 
   manually. See the link above for details.
   Finally, you can put it all together. First, run this command in R to close the "RGL Device" window:

rgl::rgl.close()

  Next, run this command in the TERMINAL. Make sure that you are in the right working directory and that 
  you have ffmpeg installed. The third part defines the framerate per second, the example below uses 60. 
  The fifth part must be named like your snapshots, followed by "%d.png". The last part is the name of the 
  mp4 file, or the GIF, and can be named anything you like.

system("ffmpeg -framerate 60 -i plot%d.png -pix_fmt yuv420p plot_gif.mp4")
   
   
-----------------------
   
The Problem:

I don't know how to create a 3D plot with rayshader and gpplot AND manually defined colors. Specifically, 
I didn't manage to create the 3D plot with one red distribution surrounded by blue distributions. The issue 
seems to be that rayshader uses the "color" aesthetic to make the z-axis. If you try to change the color of 
a range of observations to red/blue, the z-values of these observations will be messed up.  


-->

![](05-probability/animations/color_red_combo.gif)

This is the only part of the joint distribution that we care about. We aren't interested in what the object looks like where, for example, the number of heads is 11. That portion is irrelevant because we observed 8 heads, not 11. By using the filter function on the simulation tibble we created, we can conclude that there are a total of 465 times in our simulation in which 8 heads were observed.

As we would expect, most of the time when 8 coin tosses came up heads, the value of $p$ was 0.4. But, on numerous occasions, it was not. It is quite common for a value of $p$ like 0.3 or 0.5 to generate 8 heads. Consider:

```{r, echo = FALSE}
jd_coin %>% 
  filter(heads == 8) %>% 
  ggplot(aes(p)) +
    geom_bar() +
    labs(title = expression(paste("Values of ", rho[h], " Associated with 8 Heads")),
         x = expression(paste("Assumed value of ", rho[h], " in simulation")),
         y = "Count") +
  theme_classic()

```

Yet this is a distribution of raw counts. It is an unnormalized density. To turn it into a proper probability density (i.e., one in which the sum of the probabilities across possible outcomes sums to one) we just divide everything by the total number of observations.

```{r, echo = FALSE}
jd_coin %>% 
  filter(heads == 8) %>% 
  ggplot(aes(x = p)) +
    geom_histogram(aes(y = after_stat(count/sum(count))),
                   bins = 50) + 
    labs(title = expression(paste("Posterior Probability Distribution of ", rho[h])),
         x = expression(paste("Possible values for ", rho[h])),
         y = "Probability") +
    scale_x_continuous(breaks = seq(0.2, 0.7, by = 0.1)) +
    scale_y_continuous(labels = 
                        scales::percent_format(accuracy = 1)) +
  theme_classic()

```
Solution :
*The most likely value of $\rho_h$ is 0.4, as before. But, it is much more likely that $p$ is either 0.3 or 0.5. And there is about an 8% chance that $\rho_h \ge 0.6$.*

You might be wondering: what is the use of a model? Well, let's say we toss the coin 20 times and get 8 heads again. 
Given this result, Question: *what is the probability that future samples of 20 flips will result in 10 or more heads?*

There are three main ways you could go about solving this problem with simulations.

The first *wrong* way to do this is assuming that $\rho_h$ is certain because we observed 8 heads after 20 tosses. We would conclude that 8/20 gives us 0.4. The big problem with this is that you are ignoring your uncertainty when estimating $\rho_h$. This would lead us to the following code.

```{r, cache = TRUE}

sims <- 10000000

odds <- tibble(sim_ID = 1:sims) %>%
  mutate(heads = map_int(sim_ID, ~ rbinom(n = 1, size = 20, p = .4))) %>% 
  mutate(above_ten = ifelse(heads >= 10, TRUE, FALSE))

odds

```

```{r}
odds %>%
  ggplot(aes(x=heads,fill=above_ten))+
           geom_histogram(aes(y = after_stat(count/sum(count))),bins = 50)+
  scale_fill_manual(values = c('grey50', 'red'))+
  labs(title = "Posterior Probability Distribution (Wrong Way)",
         subtitle = "Number of heads in 20 tosses",
         x = "Number of heads",
         y = "Probability",
         fill = "Above ten heads") + 
    scale_x_continuous(labels = scales::number_format(accuracy = 1)) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    theme_classic()
```

Using this Posterior distribution derived from the (wrong way) simulated data, the probability results in 10 or more head is
```{r}
odds %>%
summarize(success = sum(above_ten)/sims)
```
about 24.5%

The second method involves sampling the whole posterior distribution vector we previously created. This would lead to the following correct code.

```{r}

p_draws <- tibble(p = rep(seq(0, 1, 0.1), 1000)) %>%
  mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) %>%
  filter(heads == 8)
  
odds_2nd <- tibble(p = sample(p_draws$p, size = sims, replace = TRUE)) %>%
  mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) %>% 
  mutate(above_ten = ifelse(heads >= 10, TRUE, FALSE)) 

odds_2nd


```

```{r}
odds_2nd %>%
  ggplot(aes(x = heads,fill = above_ten))+
           geom_histogram(aes(y = after_stat(count/sum(count))),bins = 50)+
  scale_fill_manual(values = c('grey50', 'red'))+
  labs(title = "Posterior Probability Distribution (Right Way 1st)",
         subtitle = "Number of heads in 20 tosses",
         x = "Number of heads",
         y = "Probability",
         fill = "Above ten heads") + 
    scale_x_continuous(labels = scales::number_format(accuracy = 1)) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    theme_classic()
```
Using this Posterior distribution derived from the (right way 1st) simulated data, the probability results in 10 or more head is
```{r}
odds_2nd %>%
summarize(success = sum(above_ten)/sims)
```
about 32.8%

Third way is to sample from the actual distribution, which is a small dataset with just a few rows, but it includes both $\rho_h$ and the probability of each $\rho_h$. This also gives the correct answer.

```{r}
p_posterior <- jd_coin %>% 
  filter(heads == 8) %>% 
  group_by(p) %>% 
  summarize(total = n(), .groups = "drop") %>%
  mutate(probs = total/sum(total))

odds_3rd <- tibble(p = sample(p_posterior$p, 
                          size = sims, 
                          prob = p_posterior$probs, 
                          replace = TRUE)) %>%
  mutate(heads = map_int(p, ~ rbinom(n = 1, 
                                     size = 20, 
                                     p = .))) %>% 
  mutate(above_ten = ifelse(heads >= 10, 
                         TRUE, 
                         FALSE)) 

odds_3rd

```


```{r}
odds_3rd %>%
  ggplot(aes(x = heads,fill = above_ten))+
           geom_histogram(aes(y = after_stat(count/sum(count))),bins = 50)+
  scale_fill_manual(values = c('grey50', 'red'))+
  labs(title = "Posterior Probability Distribution (Right Way 3rd)",
         subtitle = "Number of heads in 20 tosses",
         x = "Number of heads",
         y = "Probability",
         fill = "Above ten heads") + 
    scale_x_continuous(labels = scales::number_format(accuracy = 1)) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    theme_classic()
```

Using this Posterior distribution derived from the (right way 2nd) simulated data, the probability results in 10 or more head is
```{r}
odds_3rd %>%
summarize(success = sum(above_ten)/sims)
```
about 32% which is pretty close to the second method.


As you may have noticed, if you calculated the value using the first method, you would believe that getting 10 or more heads is less likely than it really is. If you were to run a casino based on these assumptions, you will lose all your money. It is very important to be careful about the assumptions you are making. We tossed a coin 20 times and got 8 heads. However, you would be wrong to assume that $\rho_h$ = 0.4 just based on this result.

<!-- ## Testing is evil -->

<!-- Introduce concepts like the null model, testing, and p-values. Connect to permutation tests from chapter 3.  Side note quotation: "Amateurs test. Professionals summarize." Maybe we should pick an example in which the number of heads is low enough to provide some reasonable evidence against p = 0.5. -->

<!-- In some fields, it is common to want to test a specific hypothesis. Consider the hypothesis that the coin is fair, i.e., that $p = 0.5$. Does the data we have support or reject that hypothesis? (Be wary that $p$ is both used for the probability of a head and the $p$-value of a hypothesis test.) -->

<!-- Not really interested in that exact test except in toy scenarios. -->

<!-- Difference between 0.04 and 0.06 is rarely significant. And is hardly ever a good reason to decide X over Y. -->

## Cardinal Virtues


The four [Cardinal Virtues](https://en.wikipedia.org/wiki/Cardinal_virtues) are Wisdom, Justice, Courage, and Temperance. Because data science is, ultimately, a moral act, we use these virtues to guide our work.  

* *Wisdom* begins with the ideal Preceptor Table. What data, if we had it, would allow us to answer our question easily? Then, we explore the data we have. Are the data we have close enough to the data we want that we can consider all the data as coming from the same *population*? If not, we can't proceed further. 

* *Justice* starts with the Population Table -- the data we want to have, the data which we actually have and all the other data from that same *population*. Is our data *representative* of the population? Is the meaning of the columns consistent, i.e., can we assume *validity*? We then make an assumption about the *data generating mechanism*. What general mathematical formula connects the outcome variable we are interested in with the other data that we have?

* *Courage* allows us to explore different models. Even though Justice has provided the basic mathematical structure of the model, we still need to decide which variables to include and to estimate the values of unknown parameters. We avoid hypothesis tests. We check our models for consistency with the data we have. We select one model. 

* *Temperance* guides us in the use of the model we have created to answer the questions we began with. We create posteriors of *quantities of interest*.  We should be modest in the claims we make. The posteriors we create are never the "truth." The assumptions we made to create the model are never perfect. Yet decisions made with flawed posteriors are almost always better than decisions made without them. 


### Wisdom


```{r, echo = FALSE, fig.cap = "Wisdom."}
knitr::include_graphics("other/images/Wisdom.jpg")
```

Wisdom helps us decide if we can even hope to answer our question with the data we have.

First, start with the Preceptor Table. What rows and columns of data do you need such that, if you had them all, the calculation of the quantity of interest would be trivial? If you want to know the average height of an adult in India, then the Preceptor Table would include a row for each adult and a column for their height. With no missing data, the average is easy to determine, as are a wide variety of other *estimands*, other unknown numbers. 

One key aspect of this Preceptor Table is whether or not we need more than one potential outcome in order to calculate our estimand. For example, if we want to know the causal effect of exposure to Spanish-speakers on attitude toward immigration then we need a causal model, one which estimates that attitude under both treatment and control. The Preceptor Table would require two columns for the outcome. If, on the other hand, we only want to predict someone's attitude, or compare one person's attitude to another's, then we would only need a Preceptor Table with one column for the outcome. 

Are we are modeling (just) for prediction or are we (also) modeling for causation? Predictive models care nothing about causation. Causal models are often also concerned with prediction, if only as a means of measuring the quality of the model. 

Every model is predictive, in the sense that, if we give you new data --- and it is drawn from a the same population --- then you can create a predictive forecast. But only a subset of those models are causal, meaning that, for a given individual, you can change the value of one input and figure out what the new output would be and then, from that, calculate the causal effect by looking at the difference between two potential outcomes.

With prediction, all we care about is forecasting Y given X on some as-yet-unseen data. But there is no notion of "manipulation" in such models. We don't pretend that, for Joe, we could turn variable X from a value of 5 to a value of 30 by just turning some knob and, by doing so, cause Joe's value of Y to change from 17 to 23. We can compare two people (or two groups of people), one with X equal to 5 and one with X equal to 30, and see how they differ in Y. The basic assumption of predictive models is that there is only one possible Y for Joe. There are not, by assumption, two possible values for Y, one if X equal 5 and another if X equals 30. The Preceptor Table has a single column under Y.

With causal inference, however, we can consider the case of Joe with $X = 5$ and Joe with $X = 30$. The same mathematical model can be used. And both models can be used for prediction, for estimating what the value of Y will be for a yet-unseen observation with a specified value for X. But, in this case, instead of only a single column in the Preceptor Table for Y, we have at least two (and possibly many) such columns, one for each of the potential outcomes under consideration.

*The difference between prediction models and causal models is that the former have one column for the outcome variable and the latter have more than one.* 

Second, we look at the data we have and perform an exploratory data analysis, an EDA. You can never look at your data too much. The most important variable is the one we most want to understand/explain/predict. In the models we create in later chapters, this variable will go on the lefthand side of our mathematical equations. Some academic fields refer to this as the "dependent variable." Others use terms like "regressor" or "outcome." Whatever the terminology, we need to explore the distribution of this variable, its min/max/range, its mean and median, its standard deviation, and so on.  

@roas write:

> Most important is that the data you are analyzing should map to the research question you are trying to answer. This sounds obvious but is often overlooked or ignored because it can be inconvenient. Optimally, this means that the outcome measure should accurately reflect the phenomenon of interest, the model should include all relevant predictors, and the model should generalize to the cases to which it will be applied.

> For example, with regard to the outcome variable, a model of incomes will not necessarily tell you about patterns of total assets. A model of test scores will not necessarily tell you about child intelligence or cognitive development. ...

We care about other variables as well, especially those that are most correlated/connected with the outcome variable. The more time that we spend looking at these variables, the more likely we are to create a useful model.

Third, a key concept is the "population." We need the data we want --- the Preceptor Table --- and the data we have to be similar enough that we can consider them as all having come from the same statistical population. From [Wikipedia](https://en.wikipedia.org/wiki/Statistical_population):

> In statistics, a population is a set of similar items or events which is of interest for some question or experiment. A statistical population can be a group of existing objects (e.g. the set of all stars within the Milky Way galaxy) or a hypothetical and potentially infinite group of objects conceived as a generalization from experience (e.g. the set of all possible hands in a game of poker).

If we assume that the data we have is drawn from the same population as the data in the Preceptor Table, then we can use information about the former to make inferences about the latter. We can combine the Preceptor Table and the data into a single hypothetical data set. If we can't do that, if we can't assume that the two sources come from the same population, then we can't use our data to answer our questions. We have no choice but to walk away. The heart of Wisdom is knowing when to walk away. As John Tukey noted: 

> The combination of some data and an aching desire for an answer does not ensure that a reasonable answer can be extracted from a given body of data.

### Justice

```{r, echo = FALSE, fig.cap = "Justice."}
knitr::include_graphics("other/images/Justice.jpg")
```

After Wisdom, we have an *Population Table.* It includes rows for the data we have and the data we want to have. It has missing values, most importantly for potential outcomes which were not observed. The central problem in inference is to fill in the question marks in the Population Table.

There are three key aspects of *Justice*: the data generating mechanism, representativeness and validity.

First, the *data generating mechanism* is the mathematical formula, and associated error term, which relates  our outcome variable to our covariates.  

*Justice requires math.* Consider a model of coin-tossing:


$$ H_i  \sim B(\rho_H, n = 20) $$
The total number $H$ of Heads in experiment $i$ with 20 flips of a single coin, $H_i$, is distributed as a binomial with $n = 20$ and an unknown probability $\rho_h$ of the coin coming up Heads. 
 
Note:

* This is a cheat and a simplification! We are Bayesians but we have not specified the full Bayesian machinery. We really need priors on the unknown parameter $\rho_h$ as well. But that is too complex for an introductory class, so we wave our hands, accept the default sensible parameters built into the R packages we use and point readers to more advanced books, like @roas. 

* Defining $\rho_h$ as the "the probability that the coin comes up Heads" is a bit of a fudge. If you calculate that by hand and then compare it to what our tools produce, they won't be the same. Instead, the calculated value will be closer to zero. Why? $\rho_h$ is really the "long-run percentage of the time the coin comes up Heads." It is not just the percentage from this experiment. 

<!-- DK: Unclear -->

* In this simple case, we are fortunate that the parameter $\rho_h$ has such a (mostly!) simple analog to a real world quantity. Much of the time, parameters are not so easy to interpret. In a more complex model, especially with one with interaction terms, we focus less on parameters and more on actual predictions.


* Wisdom allowed us to assume that all the rows in the actual Preceptor Table come from the same population. If that is true, then it is also true that the mathematical relationship between outcomes and covariates is consistent across these rows.

Second, we should check how "representative" the data we have is of the entire population. 

Third, confirm that the data we have accurately capturing the concepts we care about. Is the data *valid*, given the problem we are trying to solve? 



*Validity is about the columns in our tibble. Representativeness is about the rows.*


### Courage

```{r, echo = FALSE, fig.cap = "Courage."}
knitr::include_graphics("other/images/Courage.jpg")
```

The three languages of data science are words, math and code, and the most important of these is code. We need to explain the structure of our model using all three languages, but we need *Courage* to implement the model in code.

Courage requires us to take the general mathematical formula provide by Justice and then make it specific. Which variables should we include in the model and which do we exclude? Every data science project involves the creation of several models. For each, we specify the precise data generating mechanism. Using that formula, and some R code, we create a fitted model. All models have parameters. We can never know the true values of the parameters, but we can create, and explore, posterior distributions for those unknown true values.



Code allows us to "fit" a model by estimating the values of the unknown parameters, like $\rho_h$. Sadly, we can never know the true values of these parameters. But, like all good data scientists, we can express our uncertain knowledge in the form of posterior probability distributions. With those distributions, we can compare the actual values of the outcome variable with the  "fitted" or "predicted" results of the model. We can examine the "residuals," the difference between the fitted and actual values.  

Every outcome is the sum of two parts: the model and what is not in the model:

$$outcome = model + what\ is\ not\ in\ the\ model$$

It doesn't matter what the outcome is. It could be the result of a coin flip, the weight of a person, the GDP of a country. Whatever *outcome* we are considering is always made up of two parts. The first is the model we have created. The second is all the stuff --- all the blooming and buzzing complexity of the real world --- which is not a part of the model. 

Some of our uncertainty is driven by our ignorance about $\rho_h$. 

A parameter is something which does not exist in the real world. (If it did, or could, then it would be data.) Instead, a parameter is a mental abstraction, a building block which we will use to to help us accomplish our true goal: To replace at least some of the questions marks in the actual Preceptor Table. Since parameters are mental abstractions, we will always be uncertain as to their value, however much data we might collect.

But some, often most, of the uncertainty comes from forces that are, by assumption, not in the model. For example, if the coin is fair, we expect $T_i$ to equal 10. But, often, it will be different, even if we are correct and $\rho_h$ equals exactly 0.5. 

*Some randomness is intrinsic in this fallen world.* 

### Temperance

```{r, echo = FALSE, fig.cap = "Temperance."}
knitr::include_graphics("other/images/Temperance.jpg")
```


There are few more important concepts in statistics and data science than the "Data Generating Mechanism." Our *data* --- the data that we collect and see --- has been *generated* by the complexity and confusion of the world. God's own *mechanism* has brought His data to us. Our job is to build a model of that process, to create, on the computer, a mechanism which generates fake data consistent with the data which we see. With that DGM, we can answer any question which we might have. In particular, with the DGM, we provide predictions of data we have not seen and estimates of the uncertainty associated with those predictions. *Courage* helped us to create the DGM. *Temperance* will guide us in its use.

Having created (and checked) a model, we now use the model to answer questions. Models are made for use, not for beauty. The world confronts us. Make decisions we must. Our decisions will be better ones if we use high quality models to help make them.

Sadly, our models are never as good as we would like them to be. First, the world is intrinsically uncertain. 

```{r, echo = FALSE, fig.cap = "Donald Rumsfeld."}
knitr::include_graphics("05-probability/images/donald_rumsfeld.jpg")
```

> There are known knowns. There are things we know we know. We also know there are known unknowns. That is to say, we know there are some things we do not know. But there are also unknown unknowns, the ones we do not know we do not know. -- Donald Rumsfeld


What we really care about is data we haven't seen yet, mostly data from tomorrow. But what if the world changes, as it always does? If it doesn't change much, maybe we are OK. If it changes a lot, then what good will our model be? In general, the world changes some. That means that are forecasts are more uncertain that a naive use of our model might suggest. 
  
```{r, echo = FALSE, fig.cap = "Three Card Monte."}
knitr::include_graphics("05-probability/images/Three_Card_Monte.jpg")
```

What does this mean? Well imagine a crowd playing Three Card Monte in the streets of New York. The guy running the game runs a demo and shows you all the cards to make you confident. They earn money by making you overconfident and persuading you to bet. Your odds may seem good during the demo round, but that doesn't actually say anything about what will likely happen when the real, high stakes game begins. The person running the game does many simulations, making the "victim" forget that they cannot actually make any conclusions about the odds of winning. There are some variables that we simply do not know even if we put a lot of effort into making posterior probability distributions. People can be using slight of hand, for instance.

We need patience in order to study and understand the unknown unknowns in our data. Patience is also important when we analyze the "realism" of our models. When we created the mathematical probability distribution for presidential elections, for instance, we assumed that the Democratic candidate would have a 50% chance of winning each vote in the electoral college. By comparing the mathematical model to our empirical cases, however, we recognize that the mathematical model is unlikely to be true. The mathematical model suggested that getting fewer than 100 votes is next to impossible, but many past Democratic candidates in the empirical distribution received less than 100 electoral votes.

In Temperance, the key distinction is between the *true* posterior distribution --- what we will call "Preceptor's Posterior" --- and the estimated posterior distribution. Recall our discussion from Section \@ref(distributions). Imagine that every assumption we made in Wisdom and Justice were correct, that we correctly understand every aspect of how the world works. We still would not know the unknown value we are trying to estimate --- recall the Fundamental Problem of Causal Inference --- but the posterior we created would be perfect. That is Preceptor's Posterior. Sadly, even if our estimated posterior is, very close to Preceptor's Posterior, we can never be sure of that fact, because we can never know the truth, never be certain that all the assumptions we made are correct. 

Even worse, we must always worry that our estimated posterior, despite all the work we put into creating it, is far from the truth. We, therefore, must be cautious in our use of that posterior, humble in our claims about its accuracy. Using our posterior, despite its fails, is better than not using it. Yet it is, as best, a distorted map of reality, a glass through which we must look darkly. Use your posterior with humility.



<!-- DK: Could do more here. Show the iterative process of model building, including posterior predictive checks. -->

<!-- Null hypothesis testing is a mistake. There is only the data, the models and the summaries therefrom. Describe an hypothesis test each chapter, and then dismiss it. Play the prediction game. That, perhaps, provides a useful framework for why NHST is stupid. Or, rather, you play the prediction game to figure out which statistical procedures are best --- and or, how well procedure X works --- and then use that information to make a decision. Explain what a test is, and why we think it is a waste of time to do them, and why people do them anyway. Key issue: If p = 0.04 really makes you do something totally different than p = 0.06, then either you (or the system within which you are operating) is stupid. -->


## Summary

<!-- DK: Not a bad summary, but should hit the key points more clearly.  -->

*Validity is about the columns in our tibble. Representativeness is about the rows.*

Throughout this chapter, we spent time going through examples of conditional distributions. However, it's worth noting that all probability distributions are conditional on something. Even in the most simple examples, when we were flipping a coin multiple times, we were assuming that the probability of getting heads versus tails did not change between tosses.

We also discussed the difference between empirical, mathematical, and posterior probability distributions. Even though we developed these heuristics to better understand distributions, every time we make a claim about the world, it is based on our beliefs - what we think about the world. We could be wrong. Our beliefs can differ. Two reasonable people can have conflicting beliefs about the fairness of a die.

It is useful to understand the three types of distributions and the concept of conditional distributions, but almost every probability distribution is conditional and posterior. We can leave out both words in future discussions, as we generally will in this book. They are implicit.

If you are keen to learn more about probability, here is a video featuring Professor Gary King. This is a great way to review some of the concepts we covered in this chapter, albeit at a higher level of mathematics.

```{r, echo = FALSE}
knitr::include_app("https://www.youtube.com/embed/6C7yRBfh2ok")
```
